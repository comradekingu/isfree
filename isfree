#!/bin/bash

#This script is mainly intended to find out whether there is non-free/libre software 
#+in your Arch Linux machine, and, if any, to suggest a free alternative. It uses 
#+Parabola's blacklists to perform the tests.

#Blacklists can be found at: 
#  https://git.parabola.nu/blacklist.git/plain/blacklist.txt 
#or, for the AUR blacklist: 
#  https://git.parabola.nu/blacklist.git/plain/aur-blacklist.txt
#or, for the privacy blacklist:
#  https://git.parabola.nu/blacklist.git/plain/your-privacy-blacklist.txt

#Note: GitHub (https://github.com/duckinator/check-free.git) has a script called 
#+'check-free' (written by Nick Marwell (duckinator)), which is intended to do the 
#+same thing this script does. However, I'm not sure whether it works so fine, 
#+since it only recognizes -provided my script does the job well- only 6 of MY 33 
#+non-free packages.
#+GitHub also hosts a python script called absolutely-proprietary, developed by 
#+vmavromatis, which does the same thing as my script: checking Arch Linux installed
#+packages against Parabola's blacklists. See https://github.com/vmavromatis/absolutely-proprietary

#More Parabola's blacklists:
#emulator-blacklist: https://git.parabola.nu/blacklist.git/plain/your-freedom_emu-blacklist.txt

#A whitelist of GNU approved (free) software could be found here: 
#http://www.gnu.org/software/
#Parsed whitelist:
#mapfile -t gnu_whitelist < <(curl -s http://www.gnu.org/software/ | sed -n '/File generated by/,/End file generated by/p' | sed -e 's/<[^>]*>//g' | sed 's/\&nbsp\;//g')

#A list of free software ordered by categories is available at:
#http://directory.fsf.org/wiki/Main_Page

#NOTE: I use 'bc', if available, for a few floating point operations.

#Since version 0.8.7-1 I added an option (-i) to list all the installed 
#systemd packages (supporting the init freedom campaing). As a side note:
#I do not use here Parabola's your-initfreedom-blacklist, since it is
#just a fixed, and quite incomplete, list of packages names. By contrast, 
#I list systemd packages dynamically, that is, parsing the local pacman 
#database looking for packages deps, and not their names.

###COLORS### No color by default

white=""
red=""
yellow=""
green=""
cyan=""
blue=""
magenta=""
d_yellow=""
nc=""

PROG_NAME="IsFree"
ME="isfree"
VERSION="0.8.8.2"
DATE="May, 2020"
AUTHOR="L. M. Abramovich"

OFFICIAL_BLACKLIST="https://git.parabola.nu/blacklist.git/plain/blacklist.txt"
AUR_BLACKLIST="https://git.parabola.nu/blacklist.git/plain/aur-blacklist.txt"
PRIVACY_BLACKLIST="https://git.parabola.nu/blacklist.git/plain/your-privacy-blacklist.txt"
LIBRE_REPO="http://mirror.fsf.org/parabola/libre/os/$(uname -m)/libre.db"

#NOTE: About the blacklists syntax:
#original-package:[libre-replacement]:[ref]:[id]:short description, where 
#+something within [] is optional.

#Speed up the script by not using unicode
LC_ALL=C
LANG=C

###FUNCTIONS###

function echoerr ()
{
	echo -e "$@" >&2
}

function show_help ()
{
	echo -e "$PROG_NAME is fundamentally aimed to find out whether there is \
non-free/libre software installed in your Arch Linux system. When non-free \
software is found, $PROG_NAME will suggest a free alternative (taken from \
Parabola's libre repo). If the libre repo is locally enabled, it will show \
the package version as well. Secondly, $PROG_NAME can also check your \
system for systemd and systemd dependencies, supporting thus the so-called \
'init freedom'.
Exception made of the init checks, all the the tests are based on \
Parabola's blacklists, which can be found in the following URL's: 
- https://git.parabola.nu/blacklist.git/plain/blacklist.txt (blacklisted \
official Arch packages)
- https://git.parabola.nu/blacklist.git/plain/aur-blacklist.txt \
(AUR blacklisted packages)
- https://git.parabola.nu/blacklist.git/plain/your-privacy-blacklist.txt \
(privacy risking packages).
\nUsage: $ME [OPTION]... [PKG] [REPO]
-a\t\tscan your system for non-free AUR packages
-c\t\tenable colored output
-d\t\tlist systemd packages provided by your enabled repositories
-f\t\tprint an extract from 'What is Free Software?', by Richard Stallman
-h\t\tshow this help and exit
-i\t\tlist installed packages directly depending on systemd (check your \
init freedom)
-l\t\tlist all the official Arch Linux non-free packages
-m\t\tlist all the AUR non-free packages
-n\t\tscan your system for non-free native packages
-p\t\tscan the system for software that might be compromizing your privacy
-r [REPO]\tcheck an official Arch Linux repo for non-free packages
-s [PKG]\tcheck an individual package against Parabola's blacklist
-t\t\tuse Parabola's full blacklist (see note below)
-v\t\tshow program version
-x\t\tlist all the privacy threatening software
\nNOTE: By default, $PROG_NAME won't list packages considered non-free by \
Parabola's blacklist due to technical or branding issues (like pacman(!), \
systemd, filesystem, or grub), simply because these packages are by \
themselves free according to RMS definition of free-software \
(see the -f option). To use Parabola's full blacklist use the -t option."
}

function show_version ()
{
	echo -e "$PROG_NAME $VERSION ($DATE), by $AUTHOR
Released under the GPL license, version 2 or later"
}

function free_soft ()
{
	echo -e "Excerpt from ${white}'What is Free Software?'${nc} (by Richard Stallman)
Source: https://www.gnu.org/philosophy/free-sw.html\n
${cyan}\"Free software\" means software that respects users' freedom and community. Roughly, \
it means that the users have the freedom to run, copy, distribute, study, change and improve the \
software${nc}. Thus, ${cyan}\"free software\" is a matter of liberty, not price${nc}. To understand \
the concept, you should think of ${cyan}\"free\" as in \"free speech\", not as in \"free beer\"${nc}. \
We sometimes call it ${cyan}\"libre software\"${nc}, borrowing the French or Spanish word for \
\"free\" as in freedom, to show we do not mean the software is gratis.
We campaign for these freedoms because everyone deserves them. With these freedoms, the users \
(both individually and collectively) control the program and what it does for them.${cyan} When \
users don't control the program, we call it a \"nonfree\" or proprietary program. The nonfree \
program controls the users, and the developer controls the program; this makes the program an \
instrument of unjust power${nc}.
A program is free software if the program's users have the ${yellow}four essential freedoms:$nc

${yellow}-The freedom to run the program as you wish, for any purpose (freedom 0).
-The freedom to study how the program works, and change it so it does your computing as you \
wish (freedom 1). Access to the source code is a precondition for this.
-The freedom to redistribute copies so you can help your neighbor (freedom 2).
-The freedom to distribute copies of your modified versions to others (freedom 3). By doing \
this you can give the whole community a chance to benefit from your changes. Access to the source \
code is a precondition for this.$nc

A program is free software if it gives users adequately all of these freedoms. Otherwise, it \
is nonfree. While we can distinguish various nonfree distribution schemes in terms of how far \
they fall short of being free, we consider them all equally unethical (...)\n"
}

function get_blacklist ()
{
	if ! [[ -f $tmp_file ]]; then
		if ! [[ $(type -P curl) ]]; then
			echoerr "$ME: 'curl' not found"
			exit 1
		fi
		case $1 in
			aur)
				echo -ne "${green}==> ${nc}Downloading Parabola's AUR blacklist... "
				curl -s "$AUR_BLACKLIST" | sed 's/  //g' | grep -v ^'#' > "$tmp_file"
			;;
			privacy)
				echo -ne "${green}==> ${nc}Downloading Parabola's privacy blacklist... "
				curl -s "$PRIVACY_BLACKLIST" | sed 's/  //g' | grep -v ^'#' > "$tmp_file"
			;;
			*)
				echo -ne "${green}==> ${nc}Downloading Parabola's blacklist... "
				curl -s "$OFFICIAL_BLACKLIST" | sed 's/  //g' | grep -v ^'#' > "$tmp_file"
				# Add the AUR blacklist too in case of packages installed from some unofficial repo
				curl -s "$AUR_BLACKLIST" | sed 's/  //g' | grep -v ^'#' >> "$tmp_file"
			;;
		esac
		if [[ $? -eq 0 ]]; then 
			echo -e "${green}OK$nc"
		else
			echoerr "\nerror downloading file"
			exit 1
		fi
	fi
}

function parabola_repo_download ()
{
	if ! [[ -f /tmp/libre_repo_pkgs ]]; then
		if [[ $(grep "^\[libre\]" /etc/pacman.conf 2>/dev/null) ]]; then
			echo -ne "${green}==> ${nc}Getting packages from [libre] repo... "
			if pacman -Sl libre | awk '{print $2"-"$3}' > /tmp/libre_repo_pkgs; then
				echo -e "${green}OK$nc"
			fi
			return 0
		fi
		echo -ne "${green}==> ${nc}Downloading Parabola's repository database... "
		if ! [[ $(type -P wget) ]]; then 
			echoerr "\n$ME: 'wget' not found"
			exit 1
		fi
		wget -qP /tmp "$LIBRE_REPO"
		if [[ -f /tmp/libre.db ]]; then
			echo -e "${green}OK$nc"
		else
			echoerr "Error downloading file"
			exit 1
		fi
		! [[ -d /tmp/libre ]] && mkdir -p /tmp/libre
		tar xvfz /tmp/libre.db -C /tmp/libre &>/dev/null
		ls /tmp/libre > /tmp/libre_repo_pkgs
	fi
}

function blacklist_line ()
{
	pack=$1; counter=$2;
	bl_line=$(grep "^${pack}:" "$tmp_file")
	case "$bl_line" in
		*\[technical\]*|*\[branding\]*) echo -ne "${white}$counter$nc) ${green}${pack}: $nc" && technical=$((technical+1));;
		*\[nonfree\]*) echo -ne "${white}$counter$nc) ${red}${pack}: $nc" && nonfree=$((nonfree+1));;
		*\[semifree\]*|*\[uses-nonfree\]*) echo -ne "${white}$counter$nc) ${yellow}${pack}: $nc" && semifree=$((semifree+1));;
		*\[FIXME*) echo -ne "${white}$counter$nc) ${white}${pack}: $nc" && fix_doc=$((fix_doc+1));;
		*) echo -ne "${white}$counter$nc) ${blue}${pack}: $nc\n" && no_desc=$((no_desc+1));;
	esac
	#Get package description
	if [[ $nocolor -eq 0 ]]; then
		export GREP_COLOR='1;36'
		awk -F':' '{print $5,$6,$7,$8}' <<< "$bl_line" | grep --color "\[technical\]\|\[branding\]\|\[nonfree\]\|\[semifree\]\|\[uses-nonfree\]\|\[recommends-nonfree\]\|\[FIXME description\]\|\[FIXME package\]"
		export GREP_COLOR='0'
	else
		awk -F':' '{if ($5 != "") print $5,$6,$7,$8}' <<< "$bl_line"
	fi
}

function free_alternative ()
{
	pack=$1
	#Get the alternative package in the blacklist, if any
#	alternative="$(grep "^${pack}:" "$tmp_file" | cut -d":" -f2)"
	alternative="$(awk -F':' -v var="$pack" '{ if ($1 == var) print $2 }' "$tmp_file")"
	case $pack in
		firefox|chromium|opera) alternative="icecat" ;; #; replacement_counter=$((replacement_counter+1)) ;;
		vmware|virtualbox) alternative="qemu" ;; #; replacement_counter=$((replacement_counter+1)) ;;
		wps-office|yozo-office) alternative="libreoffice" ;; #; replacement_counter=$((replacement_counter+1)) ;;
		*) ;;
	esac
	#If an alternative pkg was found, check the libre repo to find the current version of
	#+of this pkg
	if [[ -n $alternative ]]; then
		replacement_counter=$((replacement_counter+1))
		alternative_version="$(grep -Ee "^${alternative}-[0-9]" /tmp/libre_repo_pkgs)"
		if [[ -n $alternative_version ]]; then
			echo -e "$tab${white}Free alternative: $nc${magenta}$alternative_version$nc"
		else
			echo -e "$tab${white}Free alternative: $nc${d_yellow}$alternative$nc"
		fi
	else
		no_alternative[${#no_alternative[@]}]=${pack}
	fi
}

function color_codes ()
{
	nonfree=$1; semifree=$2; technical=$3; fix_doc=$4; no_desc=$5
	echo -e "\n${white}Color codes:"
	[[ $nonfree -gt 0 ]] && echo -e "${red}Red:$nc Totally non-free, closed source code ${white}($nonfree)$nc."
	[[ $semifree -gt 0 ]] && echo -e "${yellow}Yellow:$nc Contains or depends on non-free software ${white}($semifree)$nc."
	[[ $technical -gt 0 ]] && echo -e "${green}Green:$nc It IS by itself free, but has some technical, branding or \
trademark issue, or simply points somehow to non-free software ${white}($technical)$nc."
	[[ $fix_doc -gt 0 ]] && echo -e "${white}White:$nc Package description needs to be corrected ${white}($fix_doc).$nc"
	[[ $no_desc -gt 0 ]] && echo -e "${blue}Blue:$nc there is no description of this package in Parabola's blacklist ${white}($no_desc)$nc."
}

function check_native ()
{
	#NOTE: native does not mean official, but installed from a repo enabled
	#in pacman.conf (be it official or not)
	tmp_file="/tmp/parabola_bl_official_full"
	get_blacklist
	if [[ $full_bl -eq 1 ]]; then :
	else #By default, remove all branding and merely technical non-free packs
		grep ":\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]\|::::$" "$tmp_file" > /tmp/parabola_bl_official
		tmp_file="/tmp/parabola_bl_official"
	fi
	#NOTE: the "::::$" condition in grep is aimed to keep lines coming from
	#the AUR blacklist 
	parabola_repo_download
	echo -ne "${green}==>$nc Getting installed native packages... "
	#Store installed native pkgs excluding parabola, hyperbola, and gnu ones
	pkgs=( $(pacman -Qn | awk '!/\.par|\.hyperbola|_gnu/{print $1}') )
	echo -e "${green}OK$nc"
	echo -e "Non-free installed native packages:${nc}\n" 
	counter=0; fix_doc=0; nonfree=0; semifree=0; technical=0; no_desc=0; replacement_counter=0
	#Compare blocks of 20 pkgs AT ONCE against the blacklist
	#This is fast! But there should be a still better solution for this
	non_free=( $(for ((i=0;i<${#pkgs[@]};i=$((i+20)))); do 
		grep "^${pkgs[$i]}:\|^${pkgs[$((i+1))]}:\|^${pkgs[$((i+2))]}:\|^${pkgs[$((i+3))]}:\|^${pkgs[$((i+4))]}:\|^${pkgs[$((i+5))]}:\|^${pkgs[$((i+6))]}:\|^${pkgs[$((i+7))]}:\|^${pkgs[$((i+8))]}:\|^${pkgs[$((i+9))]}:\|^${pkgs[$((i+10))]}:\|^${pkgs[$((i+11))]}:\|^${pkgs[$((i+12))]}:\|^${pkgs[$((i+13))]}:\|^${pkgs[$((i+14))]}:\|^${pkgs[$((i+15))]}:\|^${pkgs[$((i+16))]}:\|^${pkgs[$((i+17))]}:\|^${pkgs[$((i+18))]}:\|^${pkgs[$((i+19))]}:" "$tmp_file" | awk -F':' '{print $1}'
		done) )
	for (( i=0;i<${#non_free[@]};i++ )); do
			blacklist_line "${non_free[$i]}" "$((i+1))"
			free_alternative "${non_free[$i]}"
	done
	counter=$i
	[[ $counter -eq 0 ]] && echo -e "\n\r\e[1A${green}All your native Arch packages are free\nRMS smiles!$nc" && exit 0
	[[ $nocolor -eq 0 ]] && color_codes $nonfree $semifree $technical $fix_doc $no_desc
	echo -e "\n${cyan}Packages with no free/libre alternatives (yet):$nc"
	if [[ ${#no_alternative[@]} -gt 0 ]]; then
		for (( i=0;i<${#no_alternative[@]};i++ )); do
			echo -e "${white}$((i+1))$nc) ${no_alternative[$i]}"
		done
	else
		echo -e "None!"
	fi
	echo -e "\n-------------"
	total_packs=$(pacman -Qqn | wc -l)
	echo -e "Total installed native packages: ${white}${total_packs}$nc"
	if [[ $(type -P bc) ]]; then
		echo -e "${cyan}Non-free/libre$nc found packages:     ${cyan}$counter ($(echo "scale=1;$counter*100/${#pkgs[@]}" | bc)% of total packages)$nc"
		echo -e "${magenta}Free/libre$nc alternatives found:     ${magenta}$replacement_counter ($(echo "scale=1;$replacement_counter*100/$counter" | bc)% of non-free/libre packages)$nc"
		free_pkgs=$(echo "scale=1;((${total_packs}-${counter})*100) / $total_packs" | bc)
	else
		echo -e "${cyan}Non-free/libre$nc found packages:     ${cyan}$counter ($((counter*100/${#pkgs[@]}))% of total packages)$nc"
		echo -e "${magenta}Free/libre$nc alternatives found:     ${magenta}$replacement_counter ($((replacement_counter*100/$counter))% of non-free/libre packages)$nc"
		free_pkgs=$(echo "$(((total_packs-counter)*100/total_packs))")
	fi
	echo -e "Free/libre native Arch packages: ${white}${free_pkgs}%$nc"
#	rm /tmp/official_pkgs 2>/dev/null
}

function check_aur ()
{
	tmp_file="/tmp/parabola_bl_aur_full"
	get_blacklist "aur"
	if [[ $full_bl -eq 1 ]]; then :
	else #By default, remove all branding and merely technical non-free packs
		grep "::::$\|:\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_aur
		tmp_file="/tmp/parabola_bl_aur"
	fi
	parabola_repo_download
	echo -n "Getting installed AUR packages... "
	aur_packs=( $(pacman -Qqm) ) 
	echo -e "${green}OK$nc"
	echo -e "Non-free installed AUR packages:${nc}\n"
	counter=0; fix_doc=0; nonfree=0; semifree=0; technical=0; no_desc=0
	non_free=( $(for (( i=0;i<${#aur_packs[@]};i=$((i+10)) )); do
		grep "^${aur_packs[$i]}:\|^${aur_packs[$((i+1))]}:\|^${aur_packs[$((i+2))]}:\|^${aur_packs[$((i+3))]}:\|^${aur_packs[$((i+4))]}:\|^${aur_packs[$((i+5))]}:\|^${aur_packs[$((i+6))]}:\|^${aur_packs[$((i+7))]}:\|^${aur_packs[$((i+8))]}:\|^${aur_packs[$((i+9))]}:" "$tmp_file" | awk -F':' '{print $1}'
	done ) )
	for (( i=0;i<${#non_free[@]};i++ )); do
		blacklist_line ${non_free[$i]} $((i+1))
       	free_alternative ${non_free[$i]}
	done
	counter=$i
	[[ $counter -eq 0 ]] && echo -e "\e[1A${green}None! All your AUR packages are free!$nc" && exit 0
	[[ $nocolor -eq 0 ]] && color_codes $nonfree $semifree $technical $fix_doc $no_desc
	echo -e "\n-------------"
	echo -e "Total installed AUR packages:  ${white}${#aur_packs[@]}$nc"
	echo -e "${cyan}Non-free/libre$nc found packages: ${cyan}${counter}$nc"
}	

function check_repo ()
{
	! [[ $1 ]] && echoerr "You must specify a repository\nUsage: isfree -r [repo_name]\n" && exit 1
	#validate repo
	mapfile repos < <(grep "^\[" /etc/pacman.conf | grep -v options | tr -d '[],')
	repo=${1,,}
	[[ ${repos[@]} != *"$repo"* ]] && echoerr "'$repo': No such repository" && exit 1
	unset repos
	if [[ $repo == "libre" ]]; then
		echo -e "${green}The ${repo^^} repository is supposed to be free from \
non-free software!$nc\n\nNOTE: Since many packages in the LIBRE repo have the \
same name as those in the official repos, running this test upon the LIBRE \
repo itself will be riddled with false positives."
		exit 0
	fi
	pkgs=( $(pacman -Sql "$repo") )
	tmp_file="/tmp/parabola_bl_official_full"
	get_blacklist
	if [[ $full_bl -eq 1 ]]; then :
	else #By default, remove all branding and merely technical non-free packs
		grep ":\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_official
		tmp_file="/tmp/parabola_bl_official"
	fi
	parabola_repo_download
	echo -e "Non-free packages in ${white}'$repo'$nc repository:${nc}\n"
	nonfree_counter=0; alt_counter=0
	fix_doc=0; nonfree=0; semifree=0; technical=0; no_desc=0; 

	for (( i=0;i<${#pkgs[@]};i=$((i+20)) )); do 
		grep "^${pkgs[$i]}:\|^${pkgs[$((i+1))]}:\|^${pkgs[$((i+2))]}:\|^${pkgs[$((i+3))]}:\|^${pkgs[$((i+4))]}:\|^${pkgs[$((i+5))]}:\|^${pkgs[$((i+6))]}:\|^${pkgs[$((i+7))]}:\|^${pkgs[$((i+8))]}:\|^${pkgs[$((i+9))]}:\|^${pkgs[$((i+10))]}:\|^${pkgs[$((i+11))]}:\|^${pkgs[$((i+12))]}:\|^${pkgs[$((i+13))]}:\|^${pkgs[$((i+14))]}:\|^${pkgs[$((i+15))]}:\|^${pkgs[$((i+16))]}:\|^${pkgs[$((i+17))]}:\|^${pkgs[$((i+18))]}:\|^${pkgs[$((i+19))]}:" "$tmp_file"
	done > /tmp/non_free_repo
	IFS=":"
	while read -r line; do
		read -r pkg alt ref id desc <<< "$line"
		blacklist_line ${pkg} $((nonfree_counter+1))
		case $pkg in
			firefox|chromium|opera) alt="icecat" ;;
			vmware|virtualbox) alt="qemu" ;;
		esac
		if [[ -n $alt ]]; then
			alt_counter=$((alt_counter+1))
			alt_version="$(grep -Ee "^${alt}-[0-9]" /tmp/libre_repo_pkgs)"
			if [[ -n $alt_version ]]; then
				echo -e "$tab${white}Free alternative: $nc${magenta}$alt_version$nc"
			else
				echo -e "$tab${white}Free alternative: $nc${d_yellow}$alt$nc"
			fi
		else
			no_alternative[${#no_alternative[@]}]=$pkg
		fi 
		nonfree_counter=$((nonfree_counter+1))
	done < /tmp/non_free_repo
	rm /tmp/non_free_repo
	unset IFS

	[[ $nonfree_counter -eq 0 ]] && echo -e "${green}${repo^^} is free from non-free software!$nc" && exit 0
	[[ $nocolor -eq 0 ]] && color_codes $nonfree $semifree $technical $fix_doc $no_desc
	echo -e "\n${cyan}Packages with no free alternatives (yet):$nc"
	for (( i=0;i<${#no_alternative[@]};i++ )); do
		echo -e "${white}$((i+1))$nc) ${no_alternative[$i]}"
	done
	echo -e "\n-------------"
	echo -e "$white${repo^^}$nc\n$tab${cyan}$nonfree_counter/$(pacman -Sl "$repo" | wc -l)$nc packages are ${cyan}non-free$nc."
	echo -e "$tab${magenta}$alt_counter/$nonfree_counter$nc non-free packages have a ${magenta}free$nc alternative."
#	rm -f /tmp/libre.db
#	rm -rf /tmp/libre
}

function check_privacy ()
{
	tmp_file="/tmp/parabola_bl_privacy"
	get_blacklist "privacy"
	parabola_repo_download
	echo -n "Getting installed packages... "
	pkgs=( $(pacman -Qq) ) && echo -e "${green}OK$nc"
	echo -e "Non-secure packages installed in your system:${nc}\n" 
	counter=0; fix_doc=0; nonfree=0; semifree=0; technical=0; no_desc=0
	nonpriv=( $(for ((i=0;i<${#pkgs[@]};i=$((i+20)))); do 
		grep "^${pkgs[$i]}:\|^${pkgs[$((i+1))]}:\|^${pkgs[$((i+2))]}:\|^${pkgs[$((i+3))]}:\|^${pkgs[$((i+4))]}:\|^${pkgs[$((i+5))]}:\|^${pkgs[$((i+6))]}:\|^${pkgs[$((i+7))]}:\|^${pkgs[$((i+8))]}:\|^${pkgs[$((i+9))]}:\|^${pkgs[$((i+10))]}:\|^${pkgs[$((i+11))]}:\|^${pkgs[$((i+12))]}:\|^${pkgs[$((i+13))]}:\|^${pkgs[$((i+14))]}:\|^${pkgs[$((i+15))]}:\|^${pkgs[$((i+16))]}:\|^${pkgs[$((i+17))]}:\|^${pkgs[$((i+18))]}:\|^${pkgs[$((i+19))]}:" "$tmp_file" | awk -F':' '{print $1}'
		done) )
	for (( i=0;i<${#nonpriv[@]};i++ )); do
			blacklist_line ${nonpriv[$i]} $((i+1))
			free_alternative ${nonpriv[$i]}
	done
	counter=$i
	[[ $counter -eq 0 ]] && echo -e "${green}None! You're free from privacy risking packages!$nc" && exit 0
	[[ $nocolor -eq 0 ]] && color_codes $nonfree $semifree $technical $fix_doc $no_desc
	echo -e "\n-------------"
	echo -e "${white}${counter}/$(pacman -Q | wc -l)$nc packages might be compromizing your privacy."
}

function check_init ()
{
	echo -ne "${green}==>$white Checking init system...$nc "	
	pid1=$(realpath "$(cat /proc/1/cmdline | tr -d '\0')")
	init="$(echo ${pid1##*/})"
	case $init in
		'') echo -e "Unknown" ;;
		systemd) echo -e "$red$init$nc" ;;
		*) echo -e "$blue$init$nc" ;;
	esac

	echo -e "${green}==>$white Looking for systemd packages...$nc"
	unset sysd_pkgs
	[[ $(pacman -Qq systemd-libs) == "systemd-libs" ]] && sysd_pkgs[0]="systemd-libs"
	for inst_pkg in /var/lib/pacman/local/*; do 
		[[ $inst_pkg == *"ALPM_DB_VERSION"* ]] && continue
		dep=0
		while read -r line; do
			[[ $line == "%DEPENDS%" ]] && dep=1
			if [[ $dep -eq 1 ]]; then
				case $line in
					systemd|systemd-libs) 
						sysd_pkgs[${#sysd_pkgs[*]}]=$(sed -n '/%NAME%/{n;p}' "$inst_pkg/desc")
					;;
					'') break ;;
				esac
			fi
		done < "$inst_pkg/desc"
	done

	if [[ ${#sysd_pkgs[*]} -gt 0 ]]; then
		echo ""
		for i in ${sysd_pkgs[*]}; do
			echo -e "$yellow${i}$nc"
		done
		echo -e "\n${cyan}Total systemd packages: ${#sysd_pkgs[*]}$nc"
	else
		echo -e "${cyan}You are systemd-free!$nc"
	fi
}

function list_systemd () {
	repos=( $(grep "^\[" /etc/pacman.conf | grep -v options | tr -d '[]') )
	echo -e "${green}==>$white Getting enabled repositories...$nc \n${repos[*]}"
	echo -e "${green}==>$white Getting systemd packages...$nc "
	sysd_all=( $(pacman -Sii systemd systemd-libs | grep "Required By" | cut -d":" -f2) )
	for i in ${sysd_all[*]}; do echo "$i"; done | sort -u
	echo -e "\n${cyan}Total systemd packages: ${#sysd_all[*]}$nc"
}

function list_official ()
{
	tmp_file="/tmp/parabola_bl_official_full"
	get_blacklist
	if [[ $full_bl -eq 1 ]]; then :
	else #By default, remove all branding and merely technical non-free packs
		grep ":\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_official
		tmp_file="/tmp/parabola_bl_official"
	fi
	parabola_repo_download
	echo -e "Non-free/libre Arch official packages:\n"
	counter=0
	IFS=":"
	while read -r pkg alt ref id desc; do
		echo -e "${yellow}$((counter+1))$nc) ${cyan}${pkg}: $nc$desc"
#		echo -e ": $(echo "$line" | cut -d":" -f5-10)"
		[[ -n $alt ]] && echo -e "$tab${white}Free alternative: ${blue}$alt$nc" 
#		free_alternative "$pkg"
		counter=$((counter+1))
	done < "$tmp_file"
	unset IFS
	if [[ $nocolor -eq 0 ]]; then
		echo -e "\n${white}Color codes:$nc
${cyan}Cyan:$nc non-free package
${magenta}Magenta:$nc free alternative available in Parabola's 'libre' repository
${d_yellow}Yellow:$nc free alternative only suggested, NOT available in Parabola's 'libre' repository"
	fi
}

function list_aur ()
{
	tmp_file="/tmp/parabola_bl_aur_full"
	get_blacklist "aur"
	if [[ $full_bl -eq 1 ]]; then :
	else #By default, remove all branding and merely technical non-free packs
		grep "::::$\|:\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_aur
		tmp_file="/tmp/parabola_bl_aur"
	fi
	parabola_repo_download
	echo -e "Non-free/libre AUR packages:\n"
	counter=0
	IFS=":"
	while read -r pkg alt ref id desc; do
		echo -e "${yellow}$((counter+1))$nc) ${cyan}$pkg: $nc$desc"
		[[ -n $alt ]] && echo -e "$tab${white}Free alternative: ${blue}$alt$nc"
#		free_alternative "$pkg"
		counter=$((counter+1))
	done < "$tmp_file"
	unset IFS
	if [[ $nocolor -eq 0 ]]; then
		echo -e "\n${white}Color codes:$nc
${cyan}Cyan:$nc non-free package
${magenta}Magenta:$nc free alternative available in Parabola's 'libre' repository
${d_yellow}Yellow:$nc free alternative only suggested, NOT available in Parabola's 'libre' repository"
	fi
}

function list_privacy ()
{
	tmp_file="/tmp/parabola_bl_privacy"
	get_blacklist "privacy"
	parabola_repo_download
	echo -e "Privacy threatening software:\n"
	counter=0
	IFS=":"
	while read -r pkg alt ref id desc; do
		echo -e "${yellow}$((counter+1))$nc) ${cyan}$pkg: $nc$desc"
		[[ -n $alt ]] && echo -e "$tab${white}Secure alternative: $blue$alt$nc"
#		free_alternative "$pkg"
		counter=$((counter+1))
	done < "$tmp_file"
	unset IFS
	if [[ $nocolor -eq 0 ]]; then
		echo -e "\n${white}Color codes:$nc
${cyan}Cyan:$nc non-free package
${magenta}Magenta:$nc free alternative available in Parabola's 'libre' repository
${d_yellow}Yellow:$nc free alternative only suggested, NOT available in Parabola's 'libre' repository"
	fi
}

function check_pkg ()
{
	replacement_counter=0
	pack=${1,,}
	#Check official repositories
	echo -ne "Cheking enabled official repositories... "
	#Official repos: core extra community multilib testing community-testing multilib-testing gnome-unstable kde-unstable
	#This condition only checks locally enabled repos!!
	if [[ $(pacman -Ss ^${pack}$ | grep "core\|extra\|community\|multilib\|testing\|community-testing\|multilib-testing\|gnome-unstable\|kde-unstable") ]]; then
		echo -e "${green}Found$nc"
		tmp_file="/tmp/parabola_bl_official_full"
		get_blacklist
		if [[ $full_bl -eq 1 ]]; then :
		else #By default, remove all branding and merely technical non-free packs
			grep ":\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_official
			tmp_file="/tmp/parabola_bl_official"
		fi
	#Check AUR
	#NOTE: The following curl line is able to found AUR packages hidden 
	#+from the AUR web interface!! Example: your-freedom
	else
		echo "Not found"
		echo -ne "Checking the AUR... "
		if curl --output /dev/null --silent --head --fail https://aur.archlinux.org/cgit/aur.git/snapshot/"$pack".tar.gz; then
			echo -e "${green}Found$nc"
			tmp_file="/tmp/parabola_bl_aur_full"
			get_blacklist "aur"
			if [[ $full_bl -eq 1 ]]; then :
			else #By default, remove all branding and merely technical non-free packs
				grep "::::$\|:\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_aur
				tmp_file="/tmp/parabola_bl_aur"
			fi
		else
			echo "Not found"
			exit 1
		fi
	fi

	parabola_repo_download
	IFS=":"
	read -r pkg alt ref id desc < <(grep -m1 ^"${pack}": "$tmp_file")
	unset IFS
	if [[ -n $pkg ]]; then
		echo -ne "${red}$pack is a non-free package$nc\n${white}Description:$nc "
		if [[ $nocolor -eq 0 ]]; then
			export GREP_COLOR='1;36'
			echo "$desc" | grep --color "\[technical\]\|\[branding\]\|\[nonfree\]\|\[semifree\]\|\[uses-nonfree\]\|\[recommends-nonfree\]\|\[FIXME:description\]\|\[FIXME:package\]"
			export GREP_COLOR='0'
		else
			echo "$desc"
		fi
		free_alternative "$pkg"
		[[ $replacement_counter -eq 0 ]] && echo -e "$tab${cyan}No free/libre alternative for this package (yet).$nc"
	else
		echo -e "${green}'$pack' is not blacklisted$nc"
	fi
#	rm -f /tmp/libre.db
#	rm -rf /tmp/libre
}

###MAIN####

full_bl=0; nocolor=1; tab=""

[[ $# -eq 0 || $1 == "--help" || $1 == "help" ]] && show_help && exit 0

if ! [[ $(type -P pacman) ]]; then
	echoerr "Pacman not found: This isn't Arch Linux nor an Arch Linux based distribution"
	exit 1
fi

while getopts ":acdfhilmnpr:s:tvx" opt; do
	case $opt in
		a) check_aur ;;
		c) nocolor=0; tab="\t"
			white="\033[1;37m"; red="\033[1;31m"; yellow="\033[1;33m"
			green="\033[1;32m"; cyan="\033[1;36m"; blue="\033[1;34m"
			magenta="\033[1;35m"; d_yellow="\033[0;33m"; nc="\033[0m"
		;;
		d) list_systemd ;;
		f) free_soft ;;
		h) show_help ;;
		i) check_init ;;
		l) list_official ;;
		m) list_aur ;;
		n) check_native ;;
		p) check_privacy ;;
		r) check_repo "$OPTARG" ;;
		s) check_pkg "$OPTARG" ;;
		t) full_bl=1 ;;
		v) show_version ;;
		x) list_privacy ;;
		\?) echoerr "$ME: invalid option -- '$OPTARG'\nTry '$ME -h' for more information" ;;
		:) echoerr "$ME: option requires an argument -- '$OPTARG'\nTry '$ME -h' for more information" ;;
	esac
done

[[ -f /tmp/libre.db ]] && rm -f /tmp/libre.db
[[ -d /tmp/libre ]] && rm -rf /tmp/libre

exit 0
