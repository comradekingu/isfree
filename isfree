#!/bin/bash

#This script is mainly intended to find out whether there is non-free/libre software 
#+in your Arch Linux machine, and, if any, to suggest a free alternative. It uses 
#+Parabola's blacklists to perform the tests.

#Blacklists can be found in: 
#  https://git.parabola.nu/blacklist.git/plain/blacklist.txt 
#or, for the AUR blacklist: 
#  https://git.parabola.nu/blacklist.git/plain/aur-blacklist.txt
#or, for the privacy blacklist:
#  https://git.parabola.nu/blacklist.git/plain/your-privacy-blacklist.txt

#Note: GitHub (https://github.com/duckinator/check-free.git) has a script called 
#+'check-free' (written by Nick Marwell (duckinator)), which is intended to do the 
#+same thing this script does. However, I'm not sure whether it works so fine, 
#+since it only recognizes -provided my script does the job well- only 6 of MY 33 
#+non-free packages.
#+GitHub also hosts a python script called absolutely-proprietary, developed by 
#+vmavromatis, which does the same thing as my script: checking Arch Linux installed
#+packages against Parabola's blacklists. See https://github.com/vmavromatis/absolutely-proprietary

#More Parabola's blacklists:
#emulator-blacklist: https://git.parabola.nu/blacklist.git/plain/your-freedom_emu-blacklist.txt

#A whitelist of GNU approved (free) software could be found here: 
#http://www.gnu.org/software/
#Parsed whitelist:
#mapfile -t gnu_whitelist < <(curl -s http://www.gnu.org/software/ | sed -n '/File generated by/,/End file generated by/p' | sed -e 's/<[^>]*>//g' | sed 's/\&nbsp\;//g')

#A list of free software ordered by categories is available at:
#http://directory.fsf.org/wiki/Main_Page

#NOTE: I use 'bc', if available, for a few floating point operations.


###COLORS### No color by default

white=""
red=""
yellow=""
green=""
cyan=""
blue=""
magenta=""
d_yellow=""
nc=""

PROG_NAME="IsFree"
ME="isfree"
VERSION="0.8-5"
DATE="May, 2019"
AUTHOR="L. M. Abramovich"

OFFICIAL_BLACKLIST="https://git.parabola.nu/blacklist.git/plain/blacklist.txt"
AUR_BLACKLIST="https://git.parabola.nu/blacklist.git/plain/aur-blacklist.txt"
PRIVACY_BLACKLIST="https://git.parabola.nu/blacklist.git/plain/your-privacy-blacklist.txt"
LIBRE_REPO="http://mirror.fsf.org/parabola/libre/os/$(uname -m)/libre.db"

#NOTE: About the blacklists syntax:
#original-package:[libre-replacement]:[ref]:[id]:short description, where 
#+something within [] is optional.

###FUNCTIONS###

function echoerr ()
{
	echo -e "$@" >&2
}

function show_help ()
{
	echo -e "$PROG_NAME is fundamentally aimed to find out whether there is \
non-free/libre software installed in your Arch Linux system. When non-free software is found, \
$prog_name will suggest a free alternative, if any.
The tests are based on Parabola's blacklists, which can be found in the following sites: 
- https://git.parabola.nu/blacklist.git/plain/blacklist.txt (blacklisted official Arch packages)
- https://git.parabola.nu/blacklist.git/plain/aur-blacklist.txt (AUR blacklisted packages)
- https://git.parabola.nu/blacklist.git/plain/your-privacy-blacklist.txt (privacy risking packages).
\nUsage: $ME [OPTION]... [PKG] [REPO]
-a\t\tscan your system for non-free AUR packages
-c\t\tenable colored output
-f\t\tprint an extract from 'What is Free Software?', by Richard Stallman
-h\t\tshow this help and exit
-l\t\tlist all the official Arch Linux non-free packages
-m\t\tlist all the AUR non-free packages
-o\t\tscan your system for non-free official Arch packages
-p\t\tscan the system for software that might be compromizing your privacy
-r [REPO]\tcheck an official Arch Linux repo for non-free packages
-s [PKG]\tcheck an individual package against Parabola's blacklist
-t\t\tuse Parabola's full blacklist (see note below)
-v\t\tshow program version
-x\t\tlist all the privacy threatening software
\nNOTE: By default, $PROG_NAME won't list packages considered non-free by \
Parabola's blacklist due to technical or branding issues (like pacman(!), systemd, filesystem, or grub), \
simply because these packages are by themselves free according to RMS definition of free-software \
(see the -f option). To use Parabola's full blacklist use the -t option."
}

function show_version ()
{
	echo -e "$PROG_NAME $VERSION ($DATE), by $AUTHOR
Released under the GPL license, version 2 or later"
}

function free_soft ()
{
	echo -e "Excerpt from ${white}'What is Free Software?'${nc} (by Richard Stallman)
Source: https://www.gnu.org/philosophy/free-sw.html\n
${cyan}\"Free software\" means software that respects users' freedom and community. Roughly, \
it means that the users have the freedom to run, copy, distribute, study, change and improve the \
software${nc}. Thus, ${cyan}\"free software\" is a matter of liberty, not price${nc}. To understand \
the concept, you should think of ${cyan}\"free\" as in \"free speech\", not as in \"free beer\"${nc}. \
We sometimes call it ${cyan}\"libre software\"${nc}, borrowing the French or Spanish word for \
\"free\" as in freedom, to show we do not mean the software is gratis.
We campaign for these freedoms because everyone deserves them. With these freedoms, the users \
(both individually and collectively) control the program and what it does for them.${cyan} When \
users don't control the program, we call it a \"nonfree\" or proprietary program. The nonfree \
program controls the users, and the developer controls the program; this makes the program an \
instrument of unjust power${nc}.
A program is free software if the program's users have the ${yellow}four essential freedoms:$nc

${yellow}-The freedom to run the program as you wish, for any purpose (freedom 0).
-The freedom to study how the program works, and change it so it does your computing as you \
wish (freedom 1). Access to the source code is a precondition for this.
-The freedom to redistribute copies so you can help your neighbor (freedom 2).
-The freedom to distribute copies of your modified versions to others (freedom 3). By doing \
this you can give the whole community a chance to benefit from your changes. Access to the source \
code is a precondition for this.$nc

A program is free software if it gives users adequately all of these freedoms. Otherwise, it \
is nonfree. While we can distinguish various nonfree distribution schemes in terms of how far \
they fall short of being free, we consider them all equally unethical (...)\n"
}

function get_blacklist ()
{
	if ! [[ -f $tmp_file ]]; then
		if ! [[ $(type -P /bin/curl) ]]; then
			echoerr "$ME: 'curl' not found"
			exit 1
		fi
		case $1 in
			aur)
				echo -ne "${green}==> ${nc}Downloading Parabola's AUR blacklist... "
				/usr/bin/curl -s $AUR_BLACKLIST | sed 's/  //g' | grep -v ^'#' > $tmp_file
			;;
			privacy)
				echo -ne "${green}==> ${nc}Downloading Parabola's privacy blacklist... "
				/usr/bin/curl -s $PRIVACY_BLACKLIST | sed 's/  //g' | grep -v ^'#' > $tmp_file
			;;
			*)
				echo -ne "${green}==> ${nc}Downloading Parabola's blacklist... "
				/usr/bin/curl -s $OFFICIAL_BLACKLIST | sed 's/  //g' | grep -v ^'#' > $tmp_file
			;;
		esac
		if [[ $? -eq 0 ]]; then 
			echo -e "${green}OK$nc"
		else
			echoerr "\nerror downloading file"
			exit 1
		fi
	fi
}

function parabola_repo_download ()
{
	if ! [[ -f /tmp/libre_repo.txt ]]; then
		if [[ $(/bin/grep "^\[libre\]" /etc/pacman.conf 2>/dev/null) ]]; then
			echo -ne "${green}==> ${nc}Getting packages from [libre] repo... "
			if /bin/pacman -Sl libre | awk '{print $2"-"$3}' > /tmp/libre_repo.txt; then
				echo -e "${green}OK$nc"
			fi
			return 0
		fi
		echo -ne "${green}==> ${nc}Downloading Parabola's repository database... "
		if ! [[ $(type -P /bin/wget) ]]; then 
			echoerr "\n$ME: 'wget' not found"
			exit 1
		fi
		/bin/wget -qP /tmp "$LIBRE_REPO"
		if [[ -f /tmp/libre.db ]]; then
			echo -e "${green}OK$nc"
		else
			echoerr "Error downloading file"
			exit 1
		fi
		! [[ -d /tmp/libre ]] && /bin/mkdir -p /tmp/libre
		/bin/tar xvfz /tmp/libre.db -C /tmp/libre &>/dev/null
		/bin/ls /tmp/libre > /tmp/libre_repo.txt
	fi
}

function blacklist_line ()
{
	pack=$1; counter=$2;
	bl_line=$(grep "^${pack}:" "$tmp_file")
	case "$bl_line" in
		*\[technical\]*|*\[branding\]*) echo -ne "${white}$counter$nc) ${green}${pack}: $nc" && technical=$((technical+1));;
		*\[nonfree\]*) echo -ne "${white}$counter$nc) ${red}${pack}: $nc" && nonfree=$((nonfree+1));;
		*\[semifree\]*|*\[uses-nonfree\]*) echo -ne "${white}$counter$nc) ${yellow}${pack}: $nc" && semifree=$((semifree+1));;
		*\[FIXME*) echo -ne "${white}$counter$nc) ${white}${pack}: $nc" && fix_doc=$((fix_doc+1));;
		*) echo -ne "${white}$counter$nc) ${blue}${pack}: $nc\n" && no_desc=$((no_desc+1));;
	esac
	#Get package description
	if [[ $nocolor -eq 0 ]]; then
		export GREP_COLOR='1;36'
		/bin/awk -F':' '{print $5,$6,$7,$8}' <<< "$bl_line" | /bin/grep --color "\[technical\]\|\[branding\]\|\[nonfree\]\|\[semifree\]\|\[uses-nonfree\]\|\[FIXME description\]\|\[FIXME package\]"
		export GREP_COLOR='0'
	else
		/bin/awk -F':' '{if ($5 != "") print $5,$6,$7,$8}' <<< "$bl_line"
	fi
}

function free_alternative ()
{
	pack=$1
	#Get the alternative package in the blacklist, if any
#	alternative="$(/bin/grep "^${pack}:" "$tmp_file" | cut -d":" -f2)"
	alternative="$(/bin/awk -F':' -v var="$pack" '{ if ($1 == var) print $2 }' "$tmp_file")"
	case $pack in
		firefox|chromium|opera) alternative="icecat" ;;
		vmware|virtualbox) alternative="qemu" ;;
	esac
	#If an alternative pkg was found, check the libre repo to find the current version of
	#+of this pkg
	if [[ -n $alternative ]]; then
		alternative_version="$(/bin/grep -Ee "^${alternative}-[0-9]" /tmp/libre_repo.txt)"
		if [[ -n $alternative_version ]]; then
			echo -e "$tab${white}Free alternative: $nc${magenta}$alternative_version$nc"
			replacement_counter=$((replacement_counter+1))
		else
			echo -e "$tab${white}Free alternative: $nc${d_yellow}$alternative$nc"
		fi
	else
		no_alternative[${#no_alternative[@]}]=${pack}
	fi
}

function color_codes ()
{
	nonfree=$1; semifree=$2; technical=$3; fix_doc=$4; no_desc=$5
	echo -e "\n${white}Color codes:"
	[[ $nonfree -gt 0 ]] && echo -e "${red}Red:$nc Totally non-free, closed source code ${white}($nonfree)$nc."
	[[ $semifree -gt 0 ]] && echo -e "${yellow}Yellow:$nc Contains or depends on non-free software ${white}($semifree)$nc."
	[[ $technical -gt 0 ]] && echo -e "${green}Green:$nc It IS by itself free, but has some technical, branding or \
trademark issue, or simply points somehow to non-free software ${white}($technical)$nc."
	[[ $fix_doc -gt 0 ]] && echo -e "${white}White:$nc Package description needs to be corrected ${white}($fix_doc).$nc"
	[[ $no_desc -gt 0 ]] && echo -e "${blue}Blue:$nc there is no description of this package in Parabola's blacklist ${white}($no_desc)$nc."
}

function check_official ()
{
	tmp_file="/tmp/parabola_bl_official_full"
	get_blacklist
	if [[ $full_bl -eq 1 ]]; then :
	else #By default, remove all branding and merely technical non-free packs
		/bin/grep ":\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_official
		tmp_file="/tmp/parabola_bl_official"
	fi
	parabola_repo_download
	echo -ne "${green}==>$nc Getting installed official packages... "
	#Store installed official pkgs excluding parabola and gnu ones
	pkgs=( $(/bin/pacman -Qn | awk '!/\.par|_gnu/{print $1}') )
	echo -e "${green}OK$nc"
	echo -e "Non-free installed official packages:${nc}\n" 
	counter=0; fix_doc=0; nonfree=0; semifree=0; technical=0; no_desc=0; replacement_counter=0
	#Compare blocks of 20 pkgs AT ONCE against the blacklist
	#This is fast! But there should be a still better solution for this
	non_free=( $(for ((i=0;i<${#pkgs[@]};i=$((i+20)))); do 
		grep "^${pkgs[$i]}:\|^${pkgs[$((i+1))]}:\|^${pkgs[$((i+2))]}:\|^${pkgs[$((i+3))]}:\|^${pkgs[$((i+4))]}:\|^${pkgs[$((i+5))]}:\|^${pkgs[$((i+6))]}:\|^${pkgs[$((i+7))]}:\|^${pkgs[$((i+8))]}:\|^${pkgs[$((i+9))]}:\|^${pkgs[$((i+10))]}:\|^${pkgs[$((i+11))]}:\|^${pkgs[$((i+12))]}:\|^${pkgs[$((i+13))]}:\|^${pkgs[$((i+14))]}:\|^${pkgs[$((i+15))]}:\|^${pkgs[$((i+16))]}:\|^${pkgs[$((i+17))]}:\|^${pkgs[$((i+18))]}:\|^${pkgs[$((i+19))]}:" "$tmp_file" | awk -F':' '{print $1}'
		done) )
	for (( i=0;i<${#non_free[@]};i++ )); do
			blacklist_line "${non_free[$i]}" "$((i+1))"
			free_alternative "${non_free[$i]}"
	done
	counter=$i
	[[ $counter -eq 0 ]] && echo -e "\n${green}All your official Arch packages are free\nRMS smiles!$nc" && exit 0
	[[ $nocolor -eq 0 ]] && color_codes $nonfree $semifree $technical $fix_doc $no_desc
	echo -e "\n${cyan}Packages with no free/libre alternatives (yet):$nc"
	if [[ ${#no_alternative[@]} -gt 0 ]]; then
		for (( i=0;i<${#no_alternative[@]};i++ )); do
			echo -e "${white}$((i+1))$nc) ${no_alternative[$i]}"
		done
	else
		echo -e "None!"
	fi
	echo -e "\n-------------"
	total_packs=$(/bin/pacman -Qqn | wc -l)
	echo -e "Total installed official packages: ${white}${total_packs}$nc"
	if [[ $(type -P /bin/bc) ]]; then
		echo -e "${cyan}Non-free/libre$nc found packages:     ${cyan}$counter ($(echo "scale=1;$counter*100/${#pkgs[@]}" | bc)% of total packages)$nc"
		echo -e "${magenta}Free/libre$nc alternatives found:     ${magenta}$replacement_counter ($(echo "scale=1;$replacement_counter*100/$counter" | bc)% of non-free/libre packages)$nc"
		free_pkgs=$(echo "scale=1;((${total_packs}-${counter})*100) / $total_packs" | bc)
	else
		echo -e "${cyan}Non-free/libre$nc found packages:     ${cyan}$counter ($((counter*100/${#pkgs[@]}))% of total packages)$nc"
		echo -e "${magenta}Free/libre$nc alternatives found:     ${magenta}$replacement_counter ($((replacement_counter*100/$counter))% of non-free/libre packages)$nc"
		free_pkgs=$(echo "$(((total_packs-counter)*100/total_packs))")
	fi
	echo -e "Free/libre official Arch packages: ${white}${free_pkgs}%$nc"
#	/bin/rm /tmp/official_pkgs 2>/dev/null
}

function check_aur ()
{
	tmp_file="/tmp/parabola_bl_aur"
	get_blacklist "aur"
   	parabola_repo_download
	echo -n "Getting installed AUR packages... "
	aur_packs=( $(/bin/pacman -Qqm) ) 
	echo -e "${green}OK$nc"
	echo -e "Non-free installed AUR packages:${nc}\n"
	counter=0; fix_doc=0; nonfree=0; semifree=0; technical=0; no_desc=0
	non_free=( $(for (( i=0;i<${#aur_packs[@]};i=$((i+10)) )); do
		grep "^${aur_packs[$i]}:\|^${aur_packs[$((i+1))]}:\|^${aur_packs[$((i+2))]}:\|^${aur_packs[$((i+3))]}:\|^${aur_packs[$((i+4))]}:\|^${aur_packs[$((i+5))]}:\|^${aur_packs[$((i+6))]}:\|^${aur_packs[$((i+7))]}:\|^${aur_packs[$((i+8))]}:\|^${aur_packs[$((i+9))]}:" "$tmp_file" | awk -F':' '{print $1}'
	done ) )
	for (( i=0;i<${#non_free[@]};i++ )); do
		blacklist_line ${non_free[$i]} $((i+1))
       	free_alternative ${non_free[$i]}
	done
	counter=$i
	[[ $counter -eq 0 ]] && echo -e "${green}None! All your AUR packages are free!$nc" && exit 0
	[[ $nocolor -eq 0 ]] && color_codes $nonfree $semifree $technical $fix_doc $no_desc
	echo -e "\n-------------"
	echo -e "Total installed AUR packages:  ${white}${#aur_packs[@]}$nc"
	echo -e "${cyan}Non-free/libre$nc found packages: ${cyan}${counter}$nc"
}	

function check_repo ()
{
	! [[ $1 ]] && echoerr "You must specify a repository\nUsage: isfree -r [repo_name]\n" && exit 1
	#validate repo
	mapfile repos < <(/bin/grep "^\[" /etc/pacman.conf | /bin/grep -v options | /bin/tr -d '[],')
	repo=${1,,}
	[[ ${repos[@]} != *"$repo"* ]] && echoerr "'$repo': No such repository" && exit 1
	unset repos
	[[ $repo == "libre" ]] && echo -e "${green}${repo^^} repository is free from non-free software!$nc" && exit 0
	pkgs=( $(/bin/pacman -Sql "$repo") )
	tmp_file="/tmp/parabola_bl_official_full"
	get_blacklist
	if [[ $full_bl -eq 1 ]]; then :
	else #By default, remove all branding and merely technical non-free packs
		/bin/grep ":\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_official
		tmp_file="/tmp/parabola_bl_official"
	fi
	parabola_repo_download
	echo -e "Non-free packages in ${white}'$repo'$nc repository:${nc}\n"
	counter=0; replacement_counter=0
	fix_doc=0; nonfree=0; semifree=0; technical=0; no_desc=0; 

<<COMMENT #Much faster, but less information
	for ((i=0;i<${#pkgs[@]};i=$((i+20)))); do 
		grep "^${pkgs[$i]}:\|^${pkgs[$((i+1))]}:\|^${pkgs[$((i+2))]}:\|^${pkgs[$((i+3))]}:\|^${pkgs[$((i+4))]}:\|^${pkgs[$((i+5))]}:\|^${pkgs[$((i+6))]}:\|^${pkgs[$((i+7))]}:\|^${pkgs[$((i+8))]}:\|^${pkgs[$((i+9))]}:\|^${pkgs[$((i+10))]}:\|^${pkgs[$((i+11))]}:\|^${pkgs[$((i+12))]}:\|^${pkgs[$((i+13))]}:\|^${pkgs[$((i+14))]}:\|^${pkgs[$((i+15))]}:\|^${pkgs[$((i+16))]}:\|^${pkgs[$((i+17))]}:\|^${pkgs[$((i+18))]}:\|^${pkgs[$((i+19))]}:" "$tmp_file"
	done > /tmp/non_free_repo
	IFS=":"
	while read -r line; do
		read -r pkg alt ref id desc <<< "$line"
		echo -e "${yellow}$((counter+1))$nc - ${cyan}${pkg}: $nc$desc"
		if [[ -n $alt ]]; then
			echo -e "$tab${white}Free alternative: ${blue}$alt$nc"
			replacement_counter=$((replacement_counter+1))
		else
			no_alternative[${#no_alternative[@]}]=$pkg
		fi 
		counter=$((counter+1))
	done < /tmp/non_free_repo
	/bin/rm /tmp/non_free_repo
	unset IFS
COMMENT

	non_free=( $(for ((i=0;i<${#pkgs[@]};i=$((i+20)))); do 
		grep "^${pkgs[$i]}:\|^${pkgs[$((i+1))]}:\|^${pkgs[$((i+2))]}:\|^${pkgs[$((i+3))]}:\|^${pkgs[$((i+4))]}:\|^${pkgs[$((i+5))]}:\|^${pkgs[$((i+6))]}:\|^${pkgs[$((i+7))]}:\|^${pkgs[$((i+8))]}:\|^${pkgs[$((i+9))]}:\|^${pkgs[$((i+10))]}:\|^${pkgs[$((i+11))]}:\|^${pkgs[$((i+12))]}:\|^${pkgs[$((i+13))]}:\|^${pkgs[$((i+14))]}:\|^${pkgs[$((i+15))]}:\|^${pkgs[$((i+16))]}:\|^${pkgs[$((i+17))]}:\|^${pkgs[$((i+18))]}:\|^${pkgs[$((i+19))]}:" "$tmp_file" | awk -F':' '{print $1}'
		done) )
	for (( i=0;i<${#non_free[@]};i++ )); do
		blacklist_line ${non_free[$i]} $((i+1))
		free_alternative ${non_free[$i]}
	done
	counter=$i

	[[ $counter -eq 0 ]] && echo -e "${green}${repo^^} is free from non-free software!$nc" && exit 0
	[[ $nocolor -eq 0 ]] && color_codes $nonfree $semifree $technical $fix_doc $no_desc
	echo -e "\n${cyan}Packages with no free alternatives (yet):$nc"
	for (( i=0;i<${#no_alternative[@]};i++ )); do
		echo -e "${white}$((i+1))$nc) ${no_alternative[$i]}"
	done
	echo -e "\n-------------"
	echo -e "$white${repo^^}$nc:$tab${cyan}$counter/$(pacman -Sl "$repo" | wc -l)$nc packages are ${cyan}non-free$nc."
	echo -e "$tab${magenta}$replacement_counter/$counter$nc non-free packages have a ${magenta}free$nc alternative."
#	rm -f /tmp/libre.db
#	rm -rf /tmp/libre
}

function check_privacy ()
{
	tmp_file="/tmp/parabola_bl_privacy"
	get_blacklist "privacy"
	parabola_repo_download
	echo -n "Getting installed packages... "
	pkgs=( $(/bin/pacman -Qq) ) && echo -e "${green}OK$nc"
	echo -e "Non-secure packages installed in your system:${nc}\n" 
	counter=0; fix_doc=0; nonfree=0; semifree=0; technical=0; no_desc=0
	nonpriv=( $(for ((i=0;i<${#pkgs[@]};i=$((i+20)))); do 
		grep "^${pkgs[$i]}:\|^${pkgs[$((i+1))]}:\|^${pkgs[$((i+2))]}:\|^${pkgs[$((i+3))]}:\|^${pkgs[$((i+4))]}:\|^${pkgs[$((i+5))]}:\|^${pkgs[$((i+6))]}:\|^${pkgs[$((i+7))]}:\|^${pkgs[$((i+8))]}:\|^${pkgs[$((i+9))]}:\|^${pkgs[$((i+10))]}:\|^${pkgs[$((i+11))]}:\|^${pkgs[$((i+12))]}:\|^${pkgs[$((i+13))]}:\|^${pkgs[$((i+14))]}:\|^${pkgs[$((i+15))]}:\|^${pkgs[$((i+16))]}:\|^${pkgs[$((i+17))]}:\|^${pkgs[$((i+18))]}:\|^${pkgs[$((i+19))]}:" "$tmp_file" | awk -F':' '{print $1}'
		done) )
	for (( i=0;i<${#nonpriv[@]};i++ )); do
			free_alternative ${nonpriv[$i]}
			blacklist_line ${nonpriv[$i]} $((i+1))
	done
	counter=$i
	[[ $counter -eq 0 ]] && echo -e "${green}None! You're free from privacy risking packages!$nc" && exit 0
	[[ $nocolor -eq 0 ]] && color_codes $nonfree $semifree $technical $fix_doc $no_desc
	echo -e "\n-------------"
	echo -e "${white}${counter}/$(pacman -Q | wc -l)$nc packages might be compromizing your privacy."
}

function list_official ()
{
	tmp_file="/tmp/parabola_bl_official_full"
	get_blacklist
	if [[ $full_bl -eq 1 ]]; then :
	else #By default, remove all branding and merely technical non-free packs
		/usr/bin/grep ":\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_official
		tmp_file="/tmp/parabola_bl_official"
	fi
	parabola_repo_download
	echo -e "Non-free/libre Arch official packages:\n"
	counter=0
	IFS=":"
	while read -r pkg alt ref id desc; do
		echo -e "${yellow}$((counter+1))$nc) ${cyan}${pkg}: $nc$desc"
#		echo -e ": $(echo "$line" | cut -d":" -f5-10)"
		[[ -n $alt ]] && echo -e "$tab${white}Free alternative: ${blue}$alt$nc" 
#		free_alternative "$pkg"
		counter=$((counter+1))
	done < "$tmp_file"
	unset IFS
	if [[ $nocolor -eq 0 ]]; then
		echo -e "\n${white}Color codes:$nc
${cyan}Cyan:$nc non-free package
${magenta}Magenta:$nc free alternative available in Parabola's 'libre' repository
${d_yellow}Yellow:$nc free alternative only suggested, NOT available in Parabola's 'libre' repository"
	fi
}

function list_aur ()
{
	tmp_file="/tmp/parabola_bl_aur"
	get_blacklist "aur"
#	if [[ $2 == "-t" ]]; then :
#	else #By default, remove all branding and merely technical non-free packs
#		/usr/bin/grep ":\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_official
#		tmp_file="/tmp/parabola_bl_official"
#	fi
	parabola_repo_download
	echo -e "Non-free/libre AUR packages:\n"
	counter=0
	IFS=":"
	while read -r pkg alt ref id desc; do
		echo -e "${yellow}$((counter+1))$nc) ${cyan}$pkg: $nc$desc"
		[[ -n $alt ]] && echo -e "$tab${white}Free alternative: ${blue}$alt$nc"
#		free_alternative "$pkg"
		counter=$((counter+1))
	done < "$tmp_file"
	unset IFS
	if [[ $nocolor -eq 0 ]]; then
		echo -e "\n${white}Color codes:$nc
${cyan}Cyan:$nc non-free package
${magenta}Magenta:$nc free alternative available in Parabola's 'libre' repository
${d_yellow}Yellow:$nc free alternative only suggested, NOT available in Parabola's 'libre' repository"
	fi
}

function list_privacy ()
{
	tmp_file="/tmp/parabola_bl_privacy"
	get_blacklist "privacy"
	parabola_repo_download
	echo -e "Privacy threatening software:\n"
	counter=0
	IFS=":"
	while read -r pkg alt ref id desc; do
		echo -e "${yellow}$((counter+1))$nc) ${cyan}$pkg: $nc$desc"
		[[ -n $alt ]] && echo -e "$tab${white}Secure alternative: $blue$alt$nc"
#		free_alternative "$pkg"
		counter=$((counter+1))
	done < "$tmp_file"
	unset IFS
	if [[ $nocolor -eq 0 ]]; then
		echo -e "\n${white}Color codes:$nc
${cyan}Cyan:$nc non-free package
${magenta}Magenta:$nc free alternative available in Parabola's 'libre' repository
${d_yellow}Yellow:$nc free alternative only suggested, NOT available in Parabola's 'libre' repository"
	fi
}

function check_pkg ()
{
	replacement_counter=0
	pack=${1,,}
	if ! [[ $(/bin/pacman -Ss ^${pack}$) ]]; then
		echoerr "'$pack': Not an official Arch Linux package" 
		exit 1
	fi
	tmp_file="/tmp/parabola_bl_official_full"
	get_blacklist
	if [[ $full_bl -eq 1 ]]; then :
	else #By default, remove all branding and merely technical non-free packs
		/bin/grep ":\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_official
		tmp_file="/tmp/parabola_bl_official"
	fi
	parabola_repo_download
	IFS=":"
	read -r pkg alt ref id desc < <(/bin/grep -m1 ^"${pack}": "$tmp_file")
	unset IFS
	if [[ -n $pkg ]]; then
		echo -ne "${red}$pack is a non-free package$nc\n${white}Description:$nc "
		if [[ $nocolor -eq 0 ]]; then
			export GREP_COLOR='1;36'
			echo "$desc" | /bin/grep --color "\[technical\]\|\[branding\]\|\[nonfree\]\|\[semifree\]\|\[uses-nonfree\]\|\[FIXME:description\]\|\[FIXME:package\]"
			export GREP_COLOR='0'
		else
			echo "$desc"
		fi
		free_alternative "$pkg"
		[[ $replacement_counter -eq 0 ]] && echo -e "$tab${cyan}No free/libre alternative for this package (yet).$nc"
	else
		echo -e "${green}'$pack' is totally free software$nc"
	fi
#	/usr/bin/rm -f /tmp/libre.db
#	/usr/bin/rm -rf /tmp/libre
}

###MAIN####

full_bl=0; nocolor=1; tab=""

[[ $# -eq 0 || $1 == "--help" || $1 == "help" ]] && show_help && exit 0

if ! [[ $(type -P /bin/pacman) ]]; then
	echoerr "Pacman not found: This isn't Arch Linux nor an Arch Linux based distribution"
	exit 1
fi

while getopts ":acfhlmopr:s:tvx" opt; do
	case $opt in
		a) check_aur ;;
		c) nocolor=0; tab="\t"
			white="\033[1;37m"; red="\033[1;31m"; yellow="\033[1;33m"
			green="\033[1;32m"; cyan="\033[1;36m"; blue="\033[1;34m"
			magenta="\033[1;35m"; d_yellow="\033[0;33m"; nc="\033[0m"
		;;
		f) free_soft ;;
		h) show_help ;;
		l) list_official ;;
		m) list_aur ;;
		o) check_official ;;
		p) check_privacy ;;
		r) check_repo "$OPTARG" ;;
		s) check_pkg "$OPTARG" ;;
		t) full_bl=1 ;;
		v) show_version ;;
		x) list_privacy ;;
		\?) echoerr "$ME: invalid option -- '$OPTARG'\nTry '$ME -h' for more information" ;;
		:) echoerr "$ME: option requires an argument -- '$OPTARG'\nTry '$ME -h' for more information" ;;
	esac
done

[[ -f /tmp/libre.db ]] && /bin/rm -f /tmp/libre.db
[[ -d /tmp/libre ]] && /bin/rm -rf /tmp/libre

exit 0
