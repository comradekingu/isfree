#!/usr/bin/env bash

#This script is mainly intended to find out whether there is non-free/libre software 
#+in your Arch Linux machine, and, if any, to suggest a free alternative. It uses 
#+Parabola's blacklists to perform the tests.

#Blacklists can be found at: 
#  https://git.parabola.nu/blacklist.git/plain/blacklist.txt 
#or, for the AUR blacklist: 
#  https://git.parabola.nu/blacklist.git/plain/aur-blacklist.txt
#or, for the privacy blacklist:
#  https://git.parabola.nu/blacklist.git/plain/your-privacy-blacklist.txt

#Note: GitHub (https://github.com/duckinator/check-free.git) has a script called 
#+'check-free' (written by Nick Marwell (duckinator)), which is intended to do the 
#+same thing this script does. However, I'm not sure whether it works so fine, 
#+since it only recognizes -provided my script does the job well- only 6 of MY 33 
#+non-free packages.
#+GitHub also hosts a python script called absolutely-proprietary, developed by 
#+vmavromatis, which does the same thing as my script: checking Arch Linux installed
#+packages against Parabola's blacklists. See https://github.com/vmavromatis/absolutely-proprietary

#More Parabola's blacklists:
#emulator-blacklist: https://git.parabola.nu/blacklist.git/plain/your-freedom_emu-blacklist.txt

#A whitelist of GNU approved (free) software could be found here: 
#http://www.gnu.org/software/
#Parsed whitelist:
#mapfile -t gnu_whitelist < <(curl -s http://www.gnu.org/software/ | sed -n '/File generated by/,/End file generated by/p' | sed -e 's/<[^>]*>//g' | sed 's/\&nbsp\;//g')

#A list of free software ordered by categories is available at:
#http://directory.fsf.org/wiki/Main_Page

#NOTE: I use 'bc', if available, for a few floating point operations.

#Since version 0.8.7-1 I added an option (-i) to list all the installed 
#systemd packages (supporting the init freedom campaing). As a side note:
#I do not use here Parabola's your-initfreedom-blacklist, since it is
#just a fixed, and quite incomplete, list of packages names. By contrast, 
#I list systemd packages dynamically, that is, parsing the local pacman 
#database looking for packages deps, and not their names.

###COLORS### No color by default

white=""
red=""
yellow=""
green=""
cyan=""
blue=""
magenta=""
d_yellow=""
bold=""
nc=""

### PROGRAM DATA ###

PROG_NAME="IsFree"
ME="isfree"
VERSION="0.8.11"
DATE="Dec, 2020"
AUTHOR="L. Abramovich"
LICENSE="GPL2"
WEBSITE="https://github.com/leo-arch/isfree"

### EXIT CODES ###

SUCCESS=0
ERROR=1

### URLS ###

OFFICIAL_BLACKLIST="https://git.parabola.nu/blacklist.git/plain/blacklist.txt"
AUR_BLACKLIST="https://git.parabola.nu/blacklist.git/plain/aur-blacklist.txt"
PRIVACY_BLACKLIST="https://git.parabola.nu/blacklist.git/plain/your-privacy-blacklist.txt"
LIBRE_REPO="http://mirror.fsf.org/parabola/libre/os/$(uname -m)/libre.db"

#NOTE: About the blacklists syntax:
#original-package:[libre-replacement]:[ref]:[id]:short description, where 
#+something within [] is optional.

#Speed up the script by not using unicode
LC_ALL=C
LANG=C


### FUNCTIONS ###

function echoerr ()
{
	echo -e "$@" >&2
}

function show_help ()
{
	echo -e "$PROG_NAME is fundamentally aimed to find out whether there is \
non-free/libre software installed in your Arch Linux system. When non-free \
software is found, $PROG_NAME will suggest a free alternative (taken from \
Parabola Linux libre repo). If the libre repo is locally enabled, it will \
show the package version as well. Secondly, $PROG_NAME can also check your \
system for systemd and systemd dependencies, supporting thus the so-called \
'init freedom'.
Exception made of the init checks, all the the tests are based on \
Parabola's blacklists, which can be found in the following URL's: 
- https://git.parabola.nu/blacklist.git/plain/blacklist.txt (blacklisted \
official Arch packages)
- https://git.parabola.nu/blacklist.git/plain/aur-blacklist.txt \
(AUR blacklisted packages)
- https://git.parabola.nu/blacklist.git/plain/your-privacy-blacklist.txt \
(privacy risking packages).
\nUsage: $ME [OPTION]... [PKG] [REPO]
-a\t\tscan your system for non-free AUR packages
-c\t\tenable colored output
-d\t\tlist systemd packages provided by your enabled repositories
-f\t\tprint an extract from 'What is Free Software?', by Richard Stallman
-h\t\tshow this help and exit
-i\t\tlist installed packages directly depending on systemd (check your \
init freedom)
-l\t\tlist all the official Arch Linux non-free packages
-m\t\tlist all the AUR non-free packages
-n\t\tscan your system for non-free native packages
-p\t\tscan the system for software that might be compromizing your privacy
-r [REPO]\tcheck an official Arch Linux repo for non-free packages
-s [PKG]\tcheck an individual package against Parabola's blacklist
-t\t\tuse Parabola's full blacklist (see note below)
-v\t\tshow program version
-x\t\tlist all the privacy threatening software
\nNOTE: By default, $PROG_NAME won't list packages considered non-free by \
Parabola's blacklist due to technical or branding issues (like pacman(!), \
systemd, filesystem, or grub), simply because these packages are by \
themselves free according to RMS definition of free-software \
(see the -f option). To use Parabola's full blacklist use the -t option."
}

function show_version ()
{
	echo -e "$PROG_NAME $VERSION ($DATE), by $AUTHOR
License: $LICENSE
Website: $WEBSITE"
}

function free_soft ()
{
	echo -e "Excerpt from $nc${bold}'What is Free Software?'$nc (by Richard Stallman)
Source: https://www.gnu.org/philosophy/free-sw.html\n
${cyan}\"Free software\" means software that respects users' freedom and community. Roughly, \
it means that the users have the freedom to run, copy, distribute, study, change and improve the \
software${nc}. Thus, ${cyan}\"free software\" is a matter of liberty, not price${nc}. To understand \
the concept, you should think of ${cyan}\"free\" as in \"free speech\", not as in \"free beer\"${nc}. \
We sometimes call it ${cyan}\"libre software\"${nc}, borrowing the French or Spanish word for \
\"free\" as in freedom, to show we do not mean the software is gratis.
We campaign for these freedoms because everyone deserves them. With these freedoms, the users \
(both individually and collectively) control the program and what it does for them.${cyan} When \
users don't control the program, we call it a \"nonfree\" or proprietary program. The nonfree \
program controls the users, and the developer controls the program; this makes the program an \
instrument of unjust power${nc}.
A program is free software if the program's users have the ${yellow}four essential freedoms:$nc

${cyan}-The freedom to run the program as you wish, for any purpose (freedom 0).
-The freedom to study how the program works, and change it so it does your computing as you \
wish (freedom 1). Access to the source code is a precondition for this.
-The freedom to redistribute copies so you can help your neighbor (freedom 2).
-The freedom to distribute copies of your modified versions to others (freedom 3). By doing \
this you can give the whole community a chance to benefit from your changes. Access to the source \
code is a precondition for this.$nc

A program is free software if it gives users adequately all of these freedoms. Otherwise, it \
is nonfree. While we can distinguish various nonfree distribution schemes in terms of how far \
they fall short of being free, we consider them all equally unethical (...)\n"
}

function get_blacklist ()
{
	if ! [[ -f $tmp_file ]]; then

		if ! [[ $(type -P curl) ]]; then
			echoerr "'curl': Command not found"
			exit $ERROR
		fi

		case $1 in

			aur)
				echo -ne "${blue}::$nc$bold Downloading Parabola's AUR blacklist...$nc "
				curl -s "$AUR_BLACKLIST" | sed 's/  //g' \
				| grep -v ^'#' > "$tmp_file"
			;;

			privacy)
				echo -ne "${blue}::$nc$bold Downloading Parabola's privacy blacklist...$nc "
				curl -s "$PRIVACY_BLACKLIST" | sed 's/  //g' \
				| grep -v ^'#' > "$tmp_file"
			;;

			*)
				echo -ne "${blue}::$nc$bold Downloading Parabola's blacklist...$nc "
				curl -s "$OFFICIAL_BLACKLIST" | sed 's/  //g' \
				| grep -v ^'#' > "$tmp_file"

				# Add the AUR blacklist too in case of packages installed from some unofficial repo
				curl -s "$AUR_BLACKLIST" | sed 's/  //g' \
				| grep -v ^'#' >> "$tmp_file"
			;;
		esac

		if [[ $? -eq 0 ]]; then 
			echo -e "${green}OK$nc"
		else
			echoerr "\n${red}[-]$nc Error downloading file"
			exit $ERROR
		fi
	fi
}

function parabola_repo_download ()
{
	if ! [[ -f /tmp/libre_repo_pkgs ]]; then

		if [[ $(grep "^\[libre\]" /etc/pacman.conf 2>/dev/null) ]]; then

			echo -ne "${blue}::$nc$bold Getting packages from [libre] repo...$nc "

			if pacman -Sl libre | awk '{print $2"-"$3}' > /tmp/libre_repo_pkgs; then
				echo -e "${green}OK$nc"
			fi

			return $SUCCESS
		fi

		echo -ne "${blue}::$nc$bold Downloading Parabola's repository database...$nc "

		if ! [[ $(type -P wget) ]]; then 
			echoerr "\n$ME: 'wget': Command not found"
			exit $ERROR
		fi

		wget -qP /tmp "$LIBRE_REPO"

		if [[ -f /tmp/libre.db ]]; then
			echo -e "${green}OK$nc"
		else
			echoerr "${red}[-]$nc Error downloading file"
			exit $ERROR
		fi

		! [[ -d /tmp/libre ]] && mkdir -p /tmp/libre

		tar xvfz /tmp/libre.db -C /tmp/libre &>/dev/null

		ls /tmp/libre > /tmp/libre_repo_pkgs
	fi
}

function blacklist_line ()
{
	pack=$1; counter=$2;
	bl_line=$(grep "^${pack}:" "$tmp_file")

	case "$bl_line" in
		*\[technical\]*|*\[branding\]*)
			echo -ne "${white}$counter$nc) ${green}${pack}: $nc" \
			&& technical=$((technical+1))
		;;
		
		*\[nonfree\]*)
			echo -ne "${white}$counter$nc) ${red}${pack}: $nc" \
			&& nonfree=$((nonfree+1))
		;;
		
		*\[semifree\]*|*\[uses-nonfree\]*)
			echo -ne "${white}$counter$nc) ${yellow}${pack}: $nc" \
			&& semifree=$((semifree+1))
		;;
		
		*\[FIXME*)
			echo -ne "${white}$counter$nc) ${white}${pack}: $nc" \
			&& fix_doc=$((fix_doc+1))
		;;
		
		*)
			echo -ne "${white}$counter$nc) ${blue}${pack}: $nc\n" \
			&& no_desc=$((no_desc+1))
		;;
	esac

	#Get package description
	if [[ $nocolor -eq 0 ]]; then
		export GREP_COLOR='1;36'

		awk -F':' '{print $5,$6,$7,$8}' <<< "$bl_line" \
		| grep --color "\[technical\]\|\[branding\]\|\[nonfree\]\|\[semifree\]\|\[uses-nonfree\]\|\[recommends-nonfree\]\|\[FIXME description\]\|\[FIXME package\]"

		export GREP_COLOR='0'

	else
		awk -F':' '{if ($5 != "") print $5,$6,$7,$8}' <<< "$bl_line"
	fi
}

function free_alternative ()
{
	pack=$1

	#Get the alternative package in the blacklist, if any
#	alternative="$(grep "^${pack}:" "$tmp_file" | cut -d":" -f2)"
	alternative="$(awk -F':' -v var="$pack" '{ if ($1 == var) print $2 }' "$tmp_file")"

	case $pack in

		firefox|chromium|opera)
			alternative="icecat" ;; #; replacement_counter=$((replacement_counter+1)) ;;

		vmware|virtualbox)
			alternative="qemu" ;; #; replacement_counter=$((replacement_counter+1)) ;;

		wps-office|yozo-office)
			alternative="libreoffice" ;; #; replacement_counter=$((replacement_counter+1)) ;;

		*) ;;
	esac

	#If an alternative pkg was found, check the libre repo to find the current version of
	#+of this pkg
	if [[ -n $alternative ]]; then
		replacement_counter=$((replacement_counter+1))

		alternative_version="$(grep -Ee "^${alternative}-[0-9]" /tmp/libre_repo_pkgs)"

		if [[ -n $alternative_version ]]; then
			echo -e "$tab${bold}Free alternative: $nc$alternative_version"
		else
			echo -e "$tab${bold}Free alternative: $nc$alternative"
		fi

	else
		no_alternative[${#no_alternative[@]}]=${pack}
	fi
}

function color_codes ()
{
	nonfree=$1; semifree=$2; technical=$3; fix_doc=$4; no_desc=$5

	echo -e "\n${bold}Color codes:"

	[[ $nonfree -gt 0 ]] && echo -e "${red}Red:$nc Totally non-free, closed source code ($nonfree)."

	[[ $semifree -gt 0 ]] && echo -e "${yellow}Yellow:$nc Contains or depends on non-free software ($semifree)."

	[[ $technical -gt 0 ]] && echo -e "${green}Green:$nc It IS by itself free, but has some technical, branding or \
trademark issue, or simply points somehow to non-free software ($technical)."

	[[ $fix_doc -gt 0 ]] && echo -e "${white}White:$nc Package description needs to be corrected ($fix_doc)."

	[[ $no_desc -gt 0 ]] && echo -e "${blue}Blue:$nc there is no description of this package in Parabola's blacklist ($no_desc)."
}

function check_native ()
{
	#NOTE: native does not mean official, but installed from a repo enabled
	#in pacman.conf (be it official or not)
	tmp_file="/tmp/parabola_bl_official_full"

	get_blacklist

	if [[ $full_bl -eq 1 ]]; then :

	else #By default, remove all branding and merely technical non-free packs
		grep ":\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]\|::::$" \
		"$tmp_file" > /tmp/parabola_bl_official
		
		tmp_file="/tmp/parabola_bl_official"
	fi

	#NOTE: the "::::$" condition in grep is aimed to keep lines coming from
	#the AUR blacklist 
	parabola_repo_download

	echo -ne "${blue}::$nc$bold Getting installed native packages...$nc "

	#Store installed native pkgs excluding parabola, hyperbola, and gnu ones
	pkgs=( $(pacman -Qn | awk '!/\.par|\.hyperbola|_gnu/{print $1}') )

	echo -e "${green}OK$nc"

	echo -e "Non-free installed native packages:${nc}\n" 

	counter=0; fix_doc=0; nonfree=0; semifree=0; technical=0; no_desc=0; replacement_counter=0

	#Compare blocks of 20 pkgs AT ONCE against the blacklist
	#This is fast! But there should be a still better solution for this
#	non_free=( $(for ((i=0;i<${#pkgs[*]};i=$((i+20)))); do
#		grep "^${pkgs[$i]}:\|^${pkgs[$((i+1))]}:\|^${pkgs[$((i+2))]}:\|^${pkgs[$((i+3))]}:\|^${pkgs[$((i+4))]}:\|^${pkgs[$((i+5))]}:\|^${pkgs[$((i+6))]}:\|^${pkgs[$((i+7))]}:\|^${pkgs[$((i+8))]}:\|^${pkgs[$((i+9))]}:\|^${pkgs[$((i+10))]}:\|^${pkgs[$((i+11))]}:\|^${pkgs[$((i+12))]}:\|^${pkgs[$((i+13))]}:\|^${pkgs[$((i+14))]}:\|^${pkgs[$((i+15))]}:\|^${pkgs[$((i+16))]}:\|^${pkgs[$((i+17))]}:\|^${pkgs[$((i+18))]}:\|^${pkgs[$((i+19))]}:" "$tmp_file" | awk -F':' '{print $1}'
#		done) )

	non_free=( $(for ((i=0;i<${#pkgs[*]};i++)); do
		grep "^${pkgs[$i]}:" "$tmp_file" | awk -F':' '{print $1}'
		done) )

	for (( i=0;i<${#non_free[*]};i++ )); do
			blacklist_line "${non_free[$i]}" "$((i+1))"
			free_alternative "${non_free[$i]}"
	done

	counter=$i

	if [[ $counter -eq 0 ]]; then
		echo -e "\e[1A${green}All your native Arch packages are free\nRMS smiles!$nc"
		exit $SUCCESS
	fi

	if [[ $nocolor -eq 0 ]]; then
		color_codes $nonfree $semifree $technical $fix_doc $no_desc
	fi

	echo -e "\n$nc${bold}Packages with no free/libre alternatives (yet):$nc"

	if [[ ${#no_alternative[@]} -gt 0 ]]; then

		for (( i=0;i<${#no_alternative[*]};i++ )); do
			echo -e "$nc${bold}$((i+1))$nc) ${no_alternative[$i]}"
		done

	else
		echo -e "None!"
	fi

	echo -e "\n-------------"

	total_packs=$(pacman -Qqn | wc -l)

	echo -e "Total installed native packages: ${total_packs}"

	if [[ $(type -P bc) ]]; then
		echo -e "$nc${red}Non-free/libre$nc found packages:     $counter ($(echo "scale=1;$counter*100/${#pkgs[@]}" | bc)% of total packages)"
		echo -e "$nc${bold}Free/libre$nc alternatives found:     $replacement_counter ($(echo "scale=1;$replacement_counter*100/$counter" | bc)% of non-free/libre packages)"
		free_pkgs=$(echo "scale=1;((${total_packs}-${counter})*100) / $total_packs" | bc)

	else
		echo -e "$nc${bold}Non-free/libre$nc found packages:     $counter ($((counter*100/${#pkgs[@]}))% of total packages)"
		echo -e "$nc${bold}Free/libre$nc alternatives found:     $replacement_counter ($((replacement_counter*100/$counter))% of non-free/libre packages)"
		free_pkgs=$(echo "$(((total_packs-counter)*100/total_packs))")
	fi

	echo -e "Free/libre native Arch packages: ${free_pkgs}%"

#	rm /tmp/official_pkgs 2>/dev/null
}

function check_aur ()
{
	tmp_file="/tmp/parabola_bl_aur_full"

	get_blacklist "aur"

	if [[ $full_bl -eq 1 ]]; then :

	else #By default, remove all branding and merely technical non-free packs
		grep "::::$\|:\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_aur
		tmp_file="/tmp/parabola_bl_aur"
	fi

	parabola_repo_download

	echo -ne "${blue}::$nc$bold Getting installed AUR packages...$nc "

	aur_packs=( $(pacman -Qqm) ) 

	echo -e "${green}OK$nc"
	echo -e "Non-free installed AUR packages:${nc}\n"

	counter=0; fix_doc=0; nonfree=0; semifree=0; technical=0; no_desc=0

	non_free=( $(for (( i=0;i<${#aur_packs[@]};i=$((i+10)) )); do
		grep "^${aur_packs[$i]}:\|^${aur_packs[$((i+1))]}:\|^${aur_packs[$((i+2))]}:\|^${aur_packs[$((i+3))]}:\|^${aur_packs[$((i+4))]}:\|^${aur_packs[$((i+5))]}:\|^${aur_packs[$((i+6))]}:\|^${aur_packs[$((i+7))]}:\|^${aur_packs[$((i+8))]}:\|^${aur_packs[$((i+9))]}:" "$tmp_file" | awk -F':' '{print $1}'
	done ) )

	for (( i=0;i<${#non_free[@]};i++ )); do
		blacklist_line ${non_free[$i]} $((i+1))
       	free_alternative ${non_free[$i]}
	done

	counter=$i

	[[ $counter -eq 0 ]] && echo -e "\e[1A${green}None! All your AUR packages are free!$nc" && exit $SUCCESS
	[[ $nocolor -eq 0 ]] && color_codes $nonfree $semifree $technical $fix_doc $no_desc

	echo -e "\n-------------"
	echo -e "Total installed AUR packages:  ${#aur_packs[*]}"
	echo -e "${red}Non-free/libre$nc found packages: ${counter}"
}	

function check_repo ()
{
	! [[ $1 ]] && echoerr "You must specify a repository\nUsage: $ME -r [repo_name]\n" && exit $ERROR
	#validate repo

	mapfile repos < <(grep "^\[" /etc/pacman.conf | grep -v options | tr -d '[],')

	repo=${1,,}

	if [[ ${repos[@]} != *"$repo"* ]]; then
		echoerr "'$repo': No such repository"
		exit $ERROR
	fi

	unset repos

	if [[ $repo == "libre" ]]; then
		echo -e "The [${repo}] repository is supposed to be free from \
non-free software!\n\nNOTE: Since many packages in the LIBRE repo have the \
same name as those in the official repos, running this test upon the [${repo}] \
repo itself will be riddled with false positives."
		exit $SUCCESS
	fi

	pkgs=( $(pacman -Sql "$repo") )

	tmp_file="/tmp/parabola_bl_official_full"

	get_blacklist

	if [[ $full_bl -eq 1 ]]; then :

	else #By default, remove all branding and merely technical non-free packs
		grep ":\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_official
		tmp_file="/tmp/parabola_bl_official"
	fi

	parabola_repo_download

	echo -e "Non-free packages in $nc${bold}'$repo'$nc repository:\n"

	nonfree_counter=0; alt_counter=0
	fix_doc=0; nonfree=0; semifree=0; technical=0; no_desc=0; 

	for (( i=0;i<${#pkgs[@]};i=$((i+20)) )); do 
		grep "^${pkgs[$i]}:\|^${pkgs[$((i+1))]}:\|^${pkgs[$((i+2))]}:\|^${pkgs[$((i+3))]}:\|^${pkgs[$((i+4))]}:\|^${pkgs[$((i+5))]}:\|^${pkgs[$((i+6))]}:\|^${pkgs[$((i+7))]}:\|^${pkgs[$((i+8))]}:\|^${pkgs[$((i+9))]}:\|^${pkgs[$((i+10))]}:\|^${pkgs[$((i+11))]}:\|^${pkgs[$((i+12))]}:\|^${pkgs[$((i+13))]}:\|^${pkgs[$((i+14))]}:\|^${pkgs[$((i+15))]}:\|^${pkgs[$((i+16))]}:\|^${pkgs[$((i+17))]}:\|^${pkgs[$((i+18))]}:\|^${pkgs[$((i+19))]}:" "$tmp_file"
	done > /tmp/non_free_repo

	IFS=":"

	while read -r line; do
		read -r pkg alt ref id desc <<< "$line"

		blacklist_line ${pkg} $((nonfree_counter+1))

		case $pkg in

			firefox|chromium|opera)
				alt="icecat" ;;

			vmware|virtualbox)
				alt="qemu" ;;
		esac

		if [[ -n $alt ]]; then

			alt_counter=$((alt_counter+1))
			alt_version="$(grep -Ee "^${alt}-[0-9]" /tmp/libre_repo_pkgs)"

			if [[ -n $alt_version ]]; then
				echo -e "$tab$$nc{bold}Free alternative:$nc $alt_version"
			else
				echo -e "$tab$nc${bold}Free alternative:$nc $alt"
			fi

		else
			no_alternative[${#no_alternative[@]}]=$pkg
		fi 

		nonfree_counter=$((nonfree_counter+1))
	done < /tmp/non_free_repo

	rm /tmp/non_free_repo

	unset IFS

	if [[ $nonfree_counter -eq 0 ]]; then
		echo -e "${green}${repo^^} is free from non-free software!$nc"
		exit $SUCCESS
	fi

	if [[ $nocolor -eq 0 ]]; then
		color_codes $nonfree $semifree $technical $fix_doc $no_desc
	fi

	echo -e "\nPackages with no free alternatives (yet):"

	for (( i=0;i<${#no_alternative[@]};i++ )); do
		echo -e "$nc${bold}$((i+1))$nc) ${no_alternative[$i]}"
	done

	echo -e "\n-------------"
	echo -e "$nc$bold${repo^^}$nc\n$tab$nonfree_counter/$(pacman -Sl "$repo" | wc -l) packages are non-free."
	echo -e "$tab$nc$bold$alt_counter/$nonfree_counter$nc non-free packages have a free alternative."

#	rm -f /tmp/libre.db
#	rm -rf /tmp/libre
}

function check_privacy ()
{
	tmp_file="/tmp/parabola_bl_privacy"

	get_blacklist "privacy"

	parabola_repo_download

	echo -ne "${blue}::$nc$bold Getting installed packages...$nc "

	pkgs=( $(pacman -Qq) ) && echo -e "${green}OK$nc"

	echo -e "Non-secure packages installed in your system:${nc}\n" 

	counter=0; fix_doc=0; nonfree=0; semifree=0; technical=0; no_desc=0

	nonpriv=( $(for ((i=0;i<${#pkgs[@]};i=$((i+20)))); do 
		grep "^${pkgs[$i]}:\|^${pkgs[$((i+1))]}:\|^${pkgs[$((i+2))]}:\|^${pkgs[$((i+3))]}:\|^${pkgs[$((i+4))]}:\|^${pkgs[$((i+5))]}:\|^${pkgs[$((i+6))]}:\|^${pkgs[$((i+7))]}:\|^${pkgs[$((i+8))]}:\|^${pkgs[$((i+9))]}:\|^${pkgs[$((i+10))]}:\|^${pkgs[$((i+11))]}:\|^${pkgs[$((i+12))]}:\|^${pkgs[$((i+13))]}:\|^${pkgs[$((i+14))]}:\|^${pkgs[$((i+15))]}:\|^${pkgs[$((i+16))]}:\|^${pkgs[$((i+17))]}:\|^${pkgs[$((i+18))]}:\|^${pkgs[$((i+19))]}:" "$tmp_file" | awk -F':' '{print $1}'
		done) )

	for (( i=0;i<${#nonpriv[@]};i++ )); do
			blacklist_line ${nonpriv[$i]} $((i+1))
			free_alternative ${nonpriv[$i]}
	done

	counter=$i
	[[ $counter -eq 0 ]] && echo -e "\e[1A${green}None! You're free from privacy risking packages!$nc" && exit $SUCCESS
	[[ $nocolor -eq 0 ]] && color_codes $nonfree $semifree $technical $fix_doc $no_desc

	echo -e "\n-------------"
	echo -e "${counter}/$(pacman -Q | wc -l) packages might be compromizing your privacy."
}

function check_init ()
{
	echo -ne "${blue}::$nc$bold Checking init system...$nc "

	pid1=$(realpath "$(cat /proc/1/cmdline | tr -d '\0')")
	init="$(echo ${pid1##*/})"

	case $init in
		'') echo -e "Unknown" ;;

		systemd) echo -e "$red$init$nc" ;;

		*) echo -e "$nc$init" ;;
	esac

	echo -e "${blue}::$nc$bold Looking for systemd packages...$nc"

	unset sysd_pkgs

	if [[ $(pacman -Qq systemd-libs) == "systemd-libs" ]]; then
		sysd_pkgs[0]="systemd-libs"
	fi

	for inst_pkg in /var/lib/pacman/local/*; do 

		[[ $inst_pkg == *"ALPM_DB_VERSION"* ]] && continue
		dep=0

		while read -r line; do
			[[ $line == "%DEPENDS%" ]] && dep=1

			if [[ $dep -eq 1 ]]; then
				case $line in

					systemd|systemd-libs) 
						sysd_pkgs[${#sysd_pkgs[*]}]=$(sed -n '/%NAME%/{n;p}' "$inst_pkg/desc")
					;;

					'') break ;;
				esac
			fi
		done < "$inst_pkg/desc"
	done

	if [[ ${#sysd_pkgs[*]} -gt 0 ]]; then
		echo ""

		for i in ${sysd_pkgs[*]}; do
			echo "${i}"
		done

		echo -e "\nTotal systemd packages: ${#sysd_pkgs[*]}"
	else
		echo -e "You are systemd-free!"
	fi
}

function list_systemd () {
	repos=( $(grep "^\[" /etc/pacman.conf | grep -v options | tr -d '[]') )

	echo -e "${blue}::$nc$bold Getting enabled repositories...$nc \n${repos[*]}"
	echo -e "${blue}::$nc$bold Getting systemd packages...$nc "

	sysd_all=( $(pacman -Sii systemd systemd-libs | grep "Required By" | cut -d":" -f2) )

	for i in ${sysd_all[*]}; do echo "$i"; done | sort -u | column

	echo -e "\nTotal systemd packages: ${#sysd_all[*]}"
}

function list_official ()
{
	tmp_file="/tmp/parabola_bl_official_full"

	get_blacklist

	if [[ $full_bl -eq 1 ]]; then :

	else #By default, remove all branding and merely technical non-free packs
		grep ":\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_official
		tmp_file="/tmp/parabola_bl_official"
	fi

	parabola_repo_download

	echo -e "Non-free/libre Arch official packages:\n"

	counter=0

	IFS=":"

	while read -r pkg alt ref id desc; do
		echo -e "${yellow}$((counter+1))$nc) ${cyan}${pkg}: $nc$desc"
#		echo -e ": $(echo "$line" | cut -d":" -f5-10)"
		
		if [[ -n $alt ]]; then
			echo -e "$tab$nc${bold}Free alternative:$nc $alt" 
		fi
		
		counter=$((counter+1))
	done < "$tmp_file"

	unset IFS

	if [[ $nocolor -eq 0 ]]; then
		echo -e "\n$nc${bold}Color codes:$nc
${cyan}Cyan:$nc non-free package
${magenta}Magenta:$nc free alternative available in Parabola's 'libre' repository
${d_yellow}Yellow:$nc free alternative only suggested, NOT available in Parabola's 'libre' repository"
	fi
}

function list_aur ()
{
	tmp_file="/tmp/parabola_bl_aur_full"

	get_blacklist "aur"

	if [[ $full_bl -eq 1 ]]; then :

	else #By default, remove all branding and merely technical non-free packs
		grep "::::$\|:\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_aur
		tmp_file="/tmp/parabola_bl_aur"
	fi

	parabola_repo_download

	echo -e "Non-free/libre AUR packages:\n"

	counter=0

	IFS=":"

	while read -r pkg alt ref id desc; do
		echo -e "${yellow}$((counter+1))$nc) ${cyan}$pkg: $nc$desc"

		if [[ -n $alt ]]; then
			echo -e "$tab${white}Free alternative: ${blue}$alt$nc"
		fi

		counter=$((counter+1))
	done < "$tmp_file"

	unset IFS

	if [[ $nocolor -eq 0 ]]; then
		echo -e "\n$nc${bold}Color codes:$nc
${cyan}Cyan:$nc non-free package
${magenta}Magenta:$nc free alternative available in Parabola's 'libre' repository
${d_yellow}Yellow:$nc free alternative only suggested, NOT available in Parabola's 'libre' repository"
	fi
}

function list_privacy ()
{
	tmp_file="/tmp/parabola_bl_privacy"

	get_blacklist "privacy"

	parabola_repo_download

	echo -e "Privacy threatening software:\n"

	counter=0

	IFS=":"
	while read -r pkg alt ref id desc; do
		echo -e "${yellow}$((counter+1))$nc) $pkg: $desc"

		if [[ -n $alt ]]; then
			echo -e "$tab$nc${bold}Secure alternative: $alt"
		fi

		counter=$((counter+1))
	done < "$tmp_file"

	unset IFS

	if [[ $nocolor -eq 0 ]]; then
		echo -e "\n$nc${bold}Color codes:$nc
${cyan}Cyan:$nc non-free package
${magenta}Magenta:$nc free alternative available in Parabola's 'libre' repository
${d_yellow}Yellow:$nc free alternative only suggested, NOT available in Parabola's 'libre' repository"
	fi
}

function check_pkg ()
{
	replacement_counter=0
	pack=${1,,}

	#Check official repositories

	echo -ne "${blue}::$nc$bold Cheking enabled official repositories...$nc "

	#Official repos: core extra community multilib testing community-testing multilib-testing gnome-unstable kde-unstable
	#This condition only checks locally enabled repos!!
	if [[ $(pacman -Ss ^${pack}$ | grep "core\|extra\|community\|multilib\|testing\|community-testing\|multilib-testing\|gnome-unstable\|kde-unstable") ]]; then
		echo "Found"

		tmp_file="/tmp/parabola_bl_official_full"

		get_blacklist

		if [[ $full_bl -eq 1 ]]; then :

		else #By default, remove all branding and merely technical non-free packs
			grep ":\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_official
			tmp_file="/tmp/parabola_bl_official"
		fi

	#Check AUR
	#NOTE: The following curl line is able to found AUR packages hidden 
	#+from the AUR web interface!! Example: your-freedom
	else
		echo "Not found"
		echo -ne "${blue}::$nc$bold Checking the AUR...$nc "

		if curl --output /dev/null --silent --head --fail \
		https://aur.archlinux.org/cgit/aur.git/snapshot/"$pack".tar.gz; then
			echo "Found"

			tmp_file="/tmp/parabola_bl_aur_full"

			get_blacklist "aur"

			if [[ $full_bl -eq 1 ]]; then :

			else #By default, remove all branding and merely technical non-free packs
				grep "::::$\|:\[semifree\]\|:\[nonfree\]\|:\[uses-nonfree\]" "$tmp_file" > /tmp/parabola_bl_aur
				tmp_file="/tmp/parabola_bl_aur"
			fi
		else
			echo "Not found"
			exit $ERROR
		fi
	fi

	parabola_repo_download

	IFS=":"
	read -r pkg alt ref id desc < <(grep -m1 ^"${pack}": "$tmp_file")
	unset IFS

	if [[ -n $pkg ]]; then
		echo -ne "$pack is a ${red}non-free$nc package\n${bold}Description:$nc "

		if [[ $nocolor -eq 0 ]]; then
			export GREP_COLOR='1;36'
			echo "$desc" | grep --color "\[technical\]\|\[branding\]\|\[nonfree\]\|\[semifree\]\|\[uses-nonfree\]\|\[recommends-nonfree\]\|\[FIXME:description\]\|\[FIXME:package\]"
			export GREP_COLOR='0'
		else
			echo "$desc"
		fi

		free_alternative "$pkg"

		if [[ $replacement_counter -eq 0 ]]; then
			echo -e "${tab}No free/libre alternative for this package (yet)."
		fi

	else
		echo -e "${green}[+]$nc '$pack' is not blacklisted"
	fi

#	rm -f /tmp/libre.db
#	rm -rf /tmp/libre
}


					#####################
					#       MAIN        #
					#####################

full_bl=0; nocolor=1; tab=""

[[ $# -eq 0 || $1 == "--help" || $1 == "help" ]] && show_help && exit $SUCCESS

if ! [[ $(type -P pacman) ]]; then
	echoerr "'pacman': Command not found"
	exit $ERROR
fi

while getopts ":acdfhilmnpr:s:tvx" opt; do

	case $opt in
		a) check_aur ;;
		c)
			nocolor=0; tab="\t"
			white="\033[1;37m"; red="\033[1;31m"
			yellow="\033[1;33m"; green="\033[1;32m"
			cyan="\033[1;36m"; blue="\033[1;34m"
			magenta="\033[1;35m"; d_yellow="\033[0;33m"
			nc="\033[0m"; bold="\033[1m"
		;;
		d) list_systemd ;;
		f) free_soft ;;
		h) show_help ;;
		i) check_init ;;
		l) list_official ;;
		m) list_aur ;;
		n) check_native ;;
		p) check_privacy ;;
		r) check_repo "$OPTARG" ;;
		s) check_pkg "$OPTARG" ;;
		t) full_bl=1 ;;
		v) show_version ;;
		x) list_privacy ;;
		\?) echoerr "$ME: invalid option -- '$OPTARG'\nTry '$ME -h' for more information" ;;
		:) echoerr "$ME: option requires an argument -- '$OPTARG'\nTry '$ME -h' for more information" ;;
	esac
done

[[ -f /tmp/libre.db ]] && rm -f /tmp/libre.db

[[ -d /tmp/libre ]] && rm -rf /tmp/libre

exit $SUCCESS
